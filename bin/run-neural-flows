#!/usr/bin/env bash

# Script to execute the stand-alone executable version of neural-flows
#
#USAGE:
#  # The basic form of a call is:
#  run-neural-flows '{...}' [path-to-matlab-or-matlab-run-time]
#  # where '{...}' is a valid json input for neural-flows, and where the
#  # path should only be necessary on systems that only have the matlab
#  # runtime, for systems with a full Matlab install the path should be
#  # automatically detected.
#
#  # For example, from the neural-flows root directory, on a machine
#  # with the Matlab-Runtime installed using our install-mcr script, or
#  # with a full Matlab installed, at a bash prompt run:
#  ./bin/run-neural-flows "$(< 'test/correct_test_case.json')"
#
#  # On a machine with just the Matlab runtime, installed somewhere other
#  # than the location used by our install-mcr script, or if you want to
#  # use a specific older version installed with the install-mcr script,
#  # then you need to specify the root directory for the matlab runtime, eg:
#  run-neural-flows "$(< 'test/from_api/correct_test_case.json')" ~/Matlab/MCR_R2016b/v91
#  #NOTE: MCR Version must be the version that the executable was built with.
#
#REQUIRES:
#  neuralflows -- The stand-alone executable built using nf-build
#
#DESCRIPTION:
# Sets up the MATLAB Runtime environment paths and executes the neuralflows'
# stand-alone executable.
#
# Author: Stuart A. Knock (2019-10-29)
#    Based on the broken script auto-generated by mcc.
#

# Use the header as a basic help message.
[[ "$1" =~ ^('-h'|'--help')$ ]] && { head -n $((LINENO-2)) "${BASH_SOURCE[0]}" | tail -n +2 ; exit 0 ; }

# We're only expecting two args, so error if more.
if (( $# > 2 )); then
  printf 'ERROR: %s\n' "Expect one or two arguments, you provided $#."
  printf '       %s\n' "See the USAGE section of ${BASH_SOURCE[0]} --help."
  exit 1
fi

if [[ -z "$1" ]]; then
  printf 'ERROR: %s\n' "No json inputs were provided."
  printf '       %s\n' "See the USAGE section of ${BASH_SOURCE[0]} --help."
  exit 1
fi

# Check there is a 'results' as current code requires it.
if [[ ! -d 'results' ]]; then
  printf 'ERROR: %s\n' 'The current directory does not contain a "results/" directory.'
  exit 1
fi

# Set the Matlab-Compiler-Runtime Root directory.
if (( $# != 2 )); then
  printf '%s\n' "Trying to automatically identify Matlab-Compiler-Runtime location..."

  # Try the install location used by our 'install-mcr' script.
  MCR_LATEST_INSTALL_DIR="$(find ~/Matlab/ -maxdepth 2 -type d -name 'MCR_R20[1-2][0-9][ab]' | sort -r |  sed -n '1p')"
  if [[ -n "$MCR_LATEST_INSTALL_DIR" ]]; then
    MCRROOT="$(find "$MCR_LATEST_INSTALL_DIR" -maxdepth 1 -type d -name 'v[8-9][0-9]')"
  fi

  # Failing that,
  if [[ -z "$MCRROOT" || ! -d "$MCRROOT" ]]; then
    # check for a full matlab install.
    if command -v matlab > /dev/null 2>&1 ; then
      MATLAB_EXECUTABLE_PATH="$(realpath "$(command -v matlab)")"
      MCRROOT="${MATLAB_EXECUTABLE_PATH%/bin/matlab}"
    fi
  fi

  if [[ -z "$MCRROOT" || ! -d "$MCRROOT" ]]; then
    printf 'ERROR: %s\n' 'We cannot determine path to matlab-runtime, you must provide it.'
    printf '       %s\n' "See the USAGE section of ${BASH_SOURCE[0]} --help."
    exit 1
  fi
else
  #TODO: sanatise input, removing trailing slash for example, check it is a directory...
  MCRROOT="$2"
fi

printf '%s\n' "Running using Matlab-Root: '${MCRROOT}'"

# Where am I
SCRIPT_PATH="$( cd "$(dirname "${BASH_SOURCE[0]}")" || exit 1 ; pwd -P )"

# Where is the stand-alone executable -- assumes same directory as this script.
NF_EXECUTABLE="$SCRIPT_PATH/neuralflows"
if [[ ! -f "$NF_EXECUTABLE" ]]; then
  printf 'ERROR: %s\n' "Executable does not exist: '$NF_EXECUTABLE'."
  printf '    %s\n' 'Have you run nf-build --test OR nf-build --deploy?'
  exit 1
fi

printf '%s\n' 'Setting up environment variables...'
LD_LIBRARY_PATH=".:${MCRROOT}/runtime/glnxa64"
LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${MCRROOT}/bin/glnxa64"
LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${MCRROOT}/sys/os/glnxa64"
LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${MCRROOT}/sys/opengl/lib/glnxa64"
export LD_LIBRARY_PATH
printf '%s\n' '-----------------------------'
printf '%s\n' "LD_LIBRARY_PATH is '${LD_LIBRARY_PATH}'"
printf '%s\n' '-----------------------------'

JSON_CONFIG_STRING="$1"
# printf 'JSON_CONFIG_STRING: %s\n' "$JSON_CONFIG_STRING"

# # Make a unique cache directory (some cases of multiple instances running can cause problems if sharing a cache directory).
# FILE_NAME_NOW="$(date +%FT%H%M%S)"  #ISO 8601: YYYY-mm-ddThhMMSS
# if ! MCR_CACHE_ROOT="$(mktemp -d "/dev/shm/mcr_cache_$FILE_NAME_NOW"-XXXX)"; then
#   printf 'WARNING: %s\n' 'Failed to create temporary MCR_CACHE_ROOT directory.'
# else
#   export MCR_CACHE_ROOT
# fi

# # Make a RAM backed cache directory (possible performance improvement for initialisation).
# MCR_CACHE_ROOT='/dev/shm/mcr_cache'
# if [[ ! -d "$MCR_CACHE_ROOT" ]]; then
#   if ! mkdir "$MCR_CACHE_ROOT"; then
#     printf 'ERROR: %s\n' 'Failed to create temporary MCR_CACHE_ROOT directory.'
#     exit 1
#   fi
# fi
# export MCR_CACHE_ROOT

if ! "${NF_EXECUTABLE}" "$JSON_CONFIG_STRING"; then
  printf 'ERROR: %s\n  %s\n' 'Failed trying to run:' "${NF_EXECUTABLE} '$JSON_CONFIG_STRING'"
  # # Delete the unique cache root directory we created (goes with creation block above, do not use for RAM backed performance block).
  # [[ -d "$MCR_CACHE_ROOT" ]] && rm -rf "$MCR_CACHE_ROOT"
  exit 1
fi
# # Delete the unique cache root directory we created (goes with creation block above, do not use for RAM backed performance block).
# [[ -d "$MCR_CACHE_ROOT" ]] && rm -rf "$MCR_CACHE_ROOT"

exit 0
